// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/SceneLoader.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fSceneLoader_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fSceneLoader_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fSceneLoader_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fSceneLoader_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fSceneLoader_2eproto;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class FloatValue;
struct FloatValueDefaultTypeInternal;
extern FloatValueDefaultTypeInternal _FloatValue_default_instance_;
class IntValue;
struct IntValueDefaultTypeInternal;
extern IntValueDefaultTypeInternal _IntValue_default_instance_;
class ModelData;
struct ModelDataDefaultTypeInternal;
extern ModelDataDefaultTypeInternal _ModelData_default_instance_;
class ObjectData;
struct ObjectDataDefaultTypeInternal;
extern ObjectDataDefaultTypeInternal _ObjectData_default_instance_;
class PixelData;
struct PixelDataDefaultTypeInternal;
extern PixelDataDefaultTypeInternal _PixelData_default_instance_;
class TextureData;
struct TextureDataDefaultTypeInternal;
extern TextureDataDefaultTypeInternal _TextureData_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
class VertexData;
struct VertexDataDefaultTypeInternal;
extern VertexDataDefaultTypeInternal _VertexData_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Empty* Arena::CreateMaybeMessage<::Empty>(Arena*);
template<> ::FloatValue* Arena::CreateMaybeMessage<::FloatValue>(Arena*);
template<> ::IntValue* Arena::CreateMaybeMessage<::IntValue>(Arena*);
template<> ::ModelData* Arena::CreateMaybeMessage<::ModelData>(Arena*);
template<> ::ObjectData* Arena::CreateMaybeMessage<::ObjectData>(Arena*);
template<> ::PixelData* Arena::CreateMaybeMessage<::PixelData>(Arena*);
template<> ::TextureData* Arena::CreateMaybeMessage<::TextureData>(Arena*);
template<> ::Vector3* Arena::CreateMaybeMessage<::Vector3>(Arena*);
template<> ::VertexData* Arena::CreateMaybeMessage<::VertexData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class IntValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntValue) */ {
 public:
  inline IntValue() : IntValue(nullptr) {}
  ~IntValue() override;
  explicit PROTOBUF_CONSTEXPR IntValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntValue(const IntValue& from);
  IntValue(IntValue&& from) noexcept
    : IntValue() {
    *this = ::std::move(from);
  }

  inline IntValue& operator=(const IntValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntValue& operator=(IntValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntValue* internal_default_instance() {
    return reinterpret_cast<const IntValue*>(
               &_IntValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(IntValue& a, IntValue& b) {
    a.Swap(&b);
  }
  inline void Swap(IntValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntValue& from) {
    IntValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntValue";
  }
  protected:
  explicit IntValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // int32 value = 1;
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:IntValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fSceneLoader_2eproto;
};
// -------------------------------------------------------------------

class FloatValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FloatValue) */ {
 public:
  inline FloatValue() : FloatValue(nullptr) {}
  ~FloatValue() override;
  explicit PROTOBUF_CONSTEXPR FloatValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FloatValue(const FloatValue& from);
  FloatValue(FloatValue&& from) noexcept
    : FloatValue() {
    *this = ::std::move(from);
  }

  inline FloatValue& operator=(const FloatValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatValue& operator=(FloatValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatValue* internal_default_instance() {
    return reinterpret_cast<const FloatValue*>(
               &_FloatValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FloatValue& a, FloatValue& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FloatValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FloatValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FloatValue& from) {
    FloatValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FloatValue";
  }
  protected:
  explicit FloatValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // float value = 1;
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:FloatValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fSceneLoader_2eproto;
};
// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_proto_2fSceneLoader_2eproto;
};
// -------------------------------------------------------------------

class Vector3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() override;
  explicit PROTOBUF_CONSTEXPR Vector3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector3(const Vector3& from);
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vector3& from) {
    Vector3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Vector3";
  }
  protected:
  explicit Vector3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Vector3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fSceneLoader_2eproto;
};
// -------------------------------------------------------------------

class VertexData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VertexData) */ {
 public:
  inline VertexData() : VertexData(nullptr) {}
  ~VertexData() override;
  explicit PROTOBUF_CONSTEXPR VertexData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VertexData(const VertexData& from);
  VertexData(VertexData&& from) noexcept
    : VertexData() {
    *this = ::std::move(from);
  }

  inline VertexData& operator=(const VertexData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VertexData& operator=(VertexData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VertexData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VertexData* internal_default_instance() {
    return reinterpret_cast<const VertexData*>(
               &_VertexData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(VertexData& a, VertexData& b) {
    a.Swap(&b);
  }
  inline void Swap(VertexData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VertexData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VertexData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VertexData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VertexData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VertexData& from) {
    VertexData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VertexData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VertexData";
  }
  protected:
  explicit VertexData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kNormalsFieldNumber = 2,
    kUFieldNumber = 3,
    kVFieldNumber = 4,
  };
  // .Vector3 position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Vector3& position() const;
  PROTOBUF_NODISCARD ::Vector3* release_position();
  ::Vector3* mutable_position();
  void set_allocated_position(::Vector3* position);
  private:
  const ::Vector3& _internal_position() const;
  ::Vector3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::Vector3* position);
  ::Vector3* unsafe_arena_release_position();

  // .Vector3 normals = 2;
  bool has_normals() const;
  private:
  bool _internal_has_normals() const;
  public:
  void clear_normals();
  const ::Vector3& normals() const;
  PROTOBUF_NODISCARD ::Vector3* release_normals();
  ::Vector3* mutable_normals();
  void set_allocated_normals(::Vector3* normals);
  private:
  const ::Vector3& _internal_normals() const;
  ::Vector3* _internal_mutable_normals();
  public:
  void unsafe_arena_set_allocated_normals(
      ::Vector3* normals);
  ::Vector3* unsafe_arena_release_normals();

  // float u = 3;
  void clear_u();
  float u() const;
  void set_u(float value);
  private:
  float _internal_u() const;
  void _internal_set_u(float value);
  public:

  // float v = 4;
  void clear_v();
  float v() const;
  void set_v(float value);
  private:
  float _internal_v() const;
  void _internal_set_v(float value);
  public:

  // @@protoc_insertion_point(class_scope:VertexData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Vector3* position_;
    ::Vector3* normals_;
    float u_;
    float v_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fSceneLoader_2eproto;
};
// -------------------------------------------------------------------

class ModelData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ModelData) */ {
 public:
  inline ModelData() : ModelData(nullptr) {}
  ~ModelData() override;
  explicit PROTOBUF_CONSTEXPR ModelData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelData(const ModelData& from);
  ModelData(ModelData&& from) noexcept
    : ModelData() {
    *this = ::std::move(from);
  }

  inline ModelData& operator=(const ModelData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelData& operator=(ModelData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelData* internal_default_instance() {
    return reinterpret_cast<const ModelData*>(
               &_ModelData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ModelData& a, ModelData& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModelData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModelData& from) {
    ModelData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ModelData";
  }
  protected:
  explicit ModelData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kVDataFieldNumber = 3,
    kVDataIndexFieldNumber = 2,
    kSceneProgressFieldNumber = 4,
  };
  // string modelName = 1;
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_NODISCARD std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // .VertexData vData = 3;
  bool has_vdata() const;
  private:
  bool _internal_has_vdata() const;
  public:
  void clear_vdata();
  const ::VertexData& vdata() const;
  PROTOBUF_NODISCARD ::VertexData* release_vdata();
  ::VertexData* mutable_vdata();
  void set_allocated_vdata(::VertexData* vdata);
  private:
  const ::VertexData& _internal_vdata() const;
  ::VertexData* _internal_mutable_vdata();
  public:
  void unsafe_arena_set_allocated_vdata(
      ::VertexData* vdata);
  ::VertexData* unsafe_arena_release_vdata();

  // int32 vDataIndex = 2;
  void clear_vdataindex();
  int32_t vdataindex() const;
  void set_vdataindex(int32_t value);
  private:
  int32_t _internal_vdataindex() const;
  void _internal_set_vdataindex(int32_t value);
  public:

  // float sceneProgress = 4;
  void clear_sceneprogress();
  float sceneprogress() const;
  void set_sceneprogress(float value);
  private:
  float _internal_sceneprogress() const;
  void _internal_set_sceneprogress(float value);
  public:

  // @@protoc_insertion_point(class_scope:ModelData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
    ::VertexData* vdata_;
    int32_t vdataindex_;
    float sceneprogress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fSceneLoader_2eproto;
};
// -------------------------------------------------------------------

class PixelData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PixelData) */ {
 public:
  inline PixelData() : PixelData(nullptr) {}
  ~PixelData() override;
  explicit PROTOBUF_CONSTEXPR PixelData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PixelData(const PixelData& from);
  PixelData(PixelData&& from) noexcept
    : PixelData() {
    *this = ::std::move(from);
  }

  inline PixelData& operator=(const PixelData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PixelData& operator=(PixelData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PixelData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PixelData* internal_default_instance() {
    return reinterpret_cast<const PixelData*>(
               &_PixelData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PixelData& a, PixelData& b) {
    a.Swap(&b);
  }
  inline void Swap(PixelData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PixelData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PixelData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PixelData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PixelData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PixelData& from) {
    PixelData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PixelData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PixelData";
  }
  protected:
  explicit PixelData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
    kAFieldNumber = 4,
  };
  // uint32 r = 1;
  void clear_r();
  uint32_t r() const;
  void set_r(uint32_t value);
  private:
  uint32_t _internal_r() const;
  void _internal_set_r(uint32_t value);
  public:

  // uint32 g = 2;
  void clear_g();
  uint32_t g() const;
  void set_g(uint32_t value);
  private:
  uint32_t _internal_g() const;
  void _internal_set_g(uint32_t value);
  public:

  // uint32 b = 3;
  void clear_b();
  uint32_t b() const;
  void set_b(uint32_t value);
  private:
  uint32_t _internal_b() const;
  void _internal_set_b(uint32_t value);
  public:

  // uint32 a = 4;
  void clear_a();
  uint32_t a() const;
  void set_a(uint32_t value);
  private:
  uint32_t _internal_a() const;
  void _internal_set_a(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PixelData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t r_;
    uint32_t g_;
    uint32_t b_;
    uint32_t a_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fSceneLoader_2eproto;
};
// -------------------------------------------------------------------

class TextureData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TextureData) */ {
 public:
  inline TextureData() : TextureData(nullptr) {}
  ~TextureData() override;
  explicit PROTOBUF_CONSTEXPR TextureData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextureData(const TextureData& from);
  TextureData(TextureData&& from) noexcept
    : TextureData() {
    *this = ::std::move(from);
  }

  inline TextureData& operator=(const TextureData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextureData& operator=(TextureData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextureData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextureData* internal_default_instance() {
    return reinterpret_cast<const TextureData*>(
               &_TextureData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TextureData& a, TextureData& b) {
    a.Swap(&b);
  }
  inline void Swap(TextureData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextureData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextureData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextureData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextureData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TextureData& from) {
    TextureData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextureData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TextureData";
  }
  protected:
  explicit TextureData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPixelDataBatchFieldNumber = 6,
    kTextureNameFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kHasAlphaFieldNumber = 4,
    kPixelIndexFieldNumber = 5,
    kSceneProgressFieldNumber = 7,
  };
  // repeated .PixelData pixelDataBatch = 6;
  int pixeldatabatch_size() const;
  private:
  int _internal_pixeldatabatch_size() const;
  public:
  void clear_pixeldatabatch();
  ::PixelData* mutable_pixeldatabatch(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PixelData >*
      mutable_pixeldatabatch();
  private:
  const ::PixelData& _internal_pixeldatabatch(int index) const;
  ::PixelData* _internal_add_pixeldatabatch();
  public:
  const ::PixelData& pixeldatabatch(int index) const;
  ::PixelData* add_pixeldatabatch();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PixelData >&
      pixeldatabatch() const;

  // string textureName = 1;
  void clear_texturename();
  const std::string& texturename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_texturename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_texturename();
  PROTOBUF_NODISCARD std::string* release_texturename();
  void set_allocated_texturename(std::string* texturename);
  private:
  const std::string& _internal_texturename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_texturename(const std::string& value);
  std::string* _internal_mutable_texturename();
  public:

  // int32 width = 2;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 3;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // bool hasAlpha = 4;
  void clear_hasalpha();
  bool hasalpha() const;
  void set_hasalpha(bool value);
  private:
  bool _internal_hasalpha() const;
  void _internal_set_hasalpha(bool value);
  public:

  // int32 pixelIndex = 5;
  void clear_pixelindex();
  int32_t pixelindex() const;
  void set_pixelindex(int32_t value);
  private:
  int32_t _internal_pixelindex() const;
  void _internal_set_pixelindex(int32_t value);
  public:

  // float sceneProgress = 7;
  void clear_sceneprogress();
  float sceneprogress() const;
  void set_sceneprogress(float value);
  private:
  float _internal_sceneprogress() const;
  void _internal_set_sceneprogress(float value);
  public:

  // @@protoc_insertion_point(class_scope:TextureData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PixelData > pixeldatabatch_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr texturename_;
    int32_t width_;
    int32_t height_;
    bool hasalpha_;
    int32_t pixelindex_;
    float sceneprogress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fSceneLoader_2eproto;
};
// -------------------------------------------------------------------

class ObjectData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ObjectData) */ {
 public:
  inline ObjectData() : ObjectData(nullptr) {}
  ~ObjectData() override;
  explicit PROTOBUF_CONSTEXPR ObjectData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ObjectData(const ObjectData& from);
  ObjectData(ObjectData&& from) noexcept
    : ObjectData() {
    *this = ::std::move(from);
  }

  inline ObjectData& operator=(const ObjectData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectData& operator=(ObjectData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObjectData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObjectData* internal_default_instance() {
    return reinterpret_cast<const ObjectData*>(
               &_ObjectData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ObjectData& a, ObjectData& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObjectData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ObjectData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ObjectData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ObjectData& from) {
    ObjectData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ObjectData";
  }
  protected:
  explicit ObjectData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 1,
    kTextureNameFieldNumber = 2,
    kPositionFieldNumber = 3,
    kRotationFieldNumber = 4,
    kScaleFieldNumber = 5,
    kSceneProgressFieldNumber = 6,
  };
  // string modelName = 1;
  void clear_modelname();
  const std::string& modelname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modelname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modelname();
  PROTOBUF_NODISCARD std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // string textureName = 2;
  void clear_texturename();
  const std::string& texturename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_texturename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_texturename();
  PROTOBUF_NODISCARD std::string* release_texturename();
  void set_allocated_texturename(std::string* texturename);
  private:
  const std::string& _internal_texturename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_texturename(const std::string& value);
  std::string* _internal_mutable_texturename();
  public:

  // .Vector3 position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Vector3& position() const;
  PROTOBUF_NODISCARD ::Vector3* release_position();
  ::Vector3* mutable_position();
  void set_allocated_position(::Vector3* position);
  private:
  const ::Vector3& _internal_position() const;
  ::Vector3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::Vector3* position);
  ::Vector3* unsafe_arena_release_position();

  // .Vector3 rotation = 4;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::Vector3& rotation() const;
  PROTOBUF_NODISCARD ::Vector3* release_rotation();
  ::Vector3* mutable_rotation();
  void set_allocated_rotation(::Vector3* rotation);
  private:
  const ::Vector3& _internal_rotation() const;
  ::Vector3* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::Vector3* rotation);
  ::Vector3* unsafe_arena_release_rotation();

  // .Vector3 scale = 5;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  const ::Vector3& scale() const;
  PROTOBUF_NODISCARD ::Vector3* release_scale();
  ::Vector3* mutable_scale();
  void set_allocated_scale(::Vector3* scale);
  private:
  const ::Vector3& _internal_scale() const;
  ::Vector3* _internal_mutable_scale();
  public:
  void unsafe_arena_set_allocated_scale(
      ::Vector3* scale);
  ::Vector3* unsafe_arena_release_scale();

  // float sceneProgress = 6;
  void clear_sceneprogress();
  float sceneprogress() const;
  void set_sceneprogress(float value);
  private:
  float _internal_sceneprogress() const;
  void _internal_set_sceneprogress(float value);
  public:

  // @@protoc_insertion_point(class_scope:ObjectData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr texturename_;
    ::Vector3* position_;
    ::Vector3* rotation_;
    ::Vector3* scale_;
    float sceneprogress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fSceneLoader_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IntValue

// int32 value = 1;
inline void IntValue::clear_value() {
  _impl_.value_ = 0;
}
inline int32_t IntValue::_internal_value() const {
  return _impl_.value_;
}
inline int32_t IntValue::value() const {
  // @@protoc_insertion_point(field_get:IntValue.value)
  return _internal_value();
}
inline void IntValue::_internal_set_value(int32_t value) {
  
  _impl_.value_ = value;
}
inline void IntValue::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:IntValue.value)
}

// -------------------------------------------------------------------

// FloatValue

// float value = 1;
inline void FloatValue::clear_value() {
  _impl_.value_ = 0;
}
inline float FloatValue::_internal_value() const {
  return _impl_.value_;
}
inline float FloatValue::value() const {
  // @@protoc_insertion_point(field_get:FloatValue.value)
  return _internal_value();
}
inline void FloatValue::_internal_set_value(float value) {
  
  _impl_.value_ = value;
}
inline void FloatValue::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:FloatValue.value)
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// Vector3

// float x = 1;
inline void Vector3::clear_x() {
  _impl_.x_ = 0;
}
inline float Vector3::_internal_x() const {
  return _impl_.x_;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:Vector3.x)
  return _internal_x();
}
inline void Vector3::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Vector3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Vector3.x)
}

// float y = 2;
inline void Vector3::clear_y() {
  _impl_.y_ = 0;
}
inline float Vector3::_internal_y() const {
  return _impl_.y_;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:Vector3.y)
  return _internal_y();
}
inline void Vector3::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Vector3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Vector3.y)
}

// float z = 3;
inline void Vector3::clear_z() {
  _impl_.z_ = 0;
}
inline float Vector3::_internal_z() const {
  return _impl_.z_;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:Vector3.z)
  return _internal_z();
}
inline void Vector3::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Vector3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Vector3.z)
}

// -------------------------------------------------------------------

// VertexData

// .Vector3 position = 1;
inline bool VertexData::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool VertexData::has_position() const {
  return _internal_has_position();
}
inline void VertexData::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::Vector3& VertexData::_internal_position() const {
  const ::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector3&>(
      ::_Vector3_default_instance_);
}
inline const ::Vector3& VertexData::position() const {
  // @@protoc_insertion_point(field_get:VertexData.position)
  return _internal_position();
}
inline void VertexData::unsafe_arena_set_allocated_position(
    ::Vector3* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VertexData.position)
}
inline ::Vector3* VertexData::release_position() {
  
  ::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vector3* VertexData::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:VertexData.position)
  
  ::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::Vector3* VertexData::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::Vector3* VertexData::mutable_position() {
  ::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:VertexData.position)
  return _msg;
}
inline void VertexData::set_allocated_position(::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:VertexData.position)
}

// .Vector3 normals = 2;
inline bool VertexData::_internal_has_normals() const {
  return this != internal_default_instance() && _impl_.normals_ != nullptr;
}
inline bool VertexData::has_normals() const {
  return _internal_has_normals();
}
inline void VertexData::clear_normals() {
  if (GetArenaForAllocation() == nullptr && _impl_.normals_ != nullptr) {
    delete _impl_.normals_;
  }
  _impl_.normals_ = nullptr;
}
inline const ::Vector3& VertexData::_internal_normals() const {
  const ::Vector3* p = _impl_.normals_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector3&>(
      ::_Vector3_default_instance_);
}
inline const ::Vector3& VertexData::normals() const {
  // @@protoc_insertion_point(field_get:VertexData.normals)
  return _internal_normals();
}
inline void VertexData::unsafe_arena_set_allocated_normals(
    ::Vector3* normals) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.normals_);
  }
  _impl_.normals_ = normals;
  if (normals) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:VertexData.normals)
}
inline ::Vector3* VertexData::release_normals() {
  
  ::Vector3* temp = _impl_.normals_;
  _impl_.normals_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vector3* VertexData::unsafe_arena_release_normals() {
  // @@protoc_insertion_point(field_release:VertexData.normals)
  
  ::Vector3* temp = _impl_.normals_;
  _impl_.normals_ = nullptr;
  return temp;
}
inline ::Vector3* VertexData::_internal_mutable_normals() {
  
  if (_impl_.normals_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaForAllocation());
    _impl_.normals_ = p;
  }
  return _impl_.normals_;
}
inline ::Vector3* VertexData::mutable_normals() {
  ::Vector3* _msg = _internal_mutable_normals();
  // @@protoc_insertion_point(field_mutable:VertexData.normals)
  return _msg;
}
inline void VertexData::set_allocated_normals(::Vector3* normals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.normals_;
  }
  if (normals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(normals);
    if (message_arena != submessage_arena) {
      normals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, normals, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.normals_ = normals;
  // @@protoc_insertion_point(field_set_allocated:VertexData.normals)
}

// float u = 3;
inline void VertexData::clear_u() {
  _impl_.u_ = 0;
}
inline float VertexData::_internal_u() const {
  return _impl_.u_;
}
inline float VertexData::u() const {
  // @@protoc_insertion_point(field_get:VertexData.u)
  return _internal_u();
}
inline void VertexData::_internal_set_u(float value) {
  
  _impl_.u_ = value;
}
inline void VertexData::set_u(float value) {
  _internal_set_u(value);
  // @@protoc_insertion_point(field_set:VertexData.u)
}

// float v = 4;
inline void VertexData::clear_v() {
  _impl_.v_ = 0;
}
inline float VertexData::_internal_v() const {
  return _impl_.v_;
}
inline float VertexData::v() const {
  // @@protoc_insertion_point(field_get:VertexData.v)
  return _internal_v();
}
inline void VertexData::_internal_set_v(float value) {
  
  _impl_.v_ = value;
}
inline void VertexData::set_v(float value) {
  _internal_set_v(value);
  // @@protoc_insertion_point(field_set:VertexData.v)
}

// -------------------------------------------------------------------

// ModelData

// string modelName = 1;
inline void ModelData::clear_modelname() {
  _impl_.modelname_.ClearToEmpty();
}
inline const std::string& ModelData::modelname() const {
  // @@protoc_insertion_point(field_get:ModelData.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelData::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.modelname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ModelData.modelName)
}
inline std::string* ModelData::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:ModelData.modelName)
  return _s;
}
inline const std::string& ModelData::_internal_modelname() const {
  return _impl_.modelname_.Get();
}
inline void ModelData::_internal_set_modelname(const std::string& value) {
  
  _impl_.modelname_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelData::_internal_mutable_modelname() {
  
  return _impl_.modelname_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelData::release_modelname() {
  // @@protoc_insertion_point(field_release:ModelData.modelName)
  return _impl_.modelname_.Release();
}
inline void ModelData::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  _impl_.modelname_.SetAllocated(modelname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.modelname_.IsDefault()) {
    _impl_.modelname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ModelData.modelName)
}

// int32 vDataIndex = 2;
inline void ModelData::clear_vdataindex() {
  _impl_.vdataindex_ = 0;
}
inline int32_t ModelData::_internal_vdataindex() const {
  return _impl_.vdataindex_;
}
inline int32_t ModelData::vdataindex() const {
  // @@protoc_insertion_point(field_get:ModelData.vDataIndex)
  return _internal_vdataindex();
}
inline void ModelData::_internal_set_vdataindex(int32_t value) {
  
  _impl_.vdataindex_ = value;
}
inline void ModelData::set_vdataindex(int32_t value) {
  _internal_set_vdataindex(value);
  // @@protoc_insertion_point(field_set:ModelData.vDataIndex)
}

// .VertexData vData = 3;
inline bool ModelData::_internal_has_vdata() const {
  return this != internal_default_instance() && _impl_.vdata_ != nullptr;
}
inline bool ModelData::has_vdata() const {
  return _internal_has_vdata();
}
inline void ModelData::clear_vdata() {
  if (GetArenaForAllocation() == nullptr && _impl_.vdata_ != nullptr) {
    delete _impl_.vdata_;
  }
  _impl_.vdata_ = nullptr;
}
inline const ::VertexData& ModelData::_internal_vdata() const {
  const ::VertexData* p = _impl_.vdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::VertexData&>(
      ::_VertexData_default_instance_);
}
inline const ::VertexData& ModelData::vdata() const {
  // @@protoc_insertion_point(field_get:ModelData.vData)
  return _internal_vdata();
}
inline void ModelData::unsafe_arena_set_allocated_vdata(
    ::VertexData* vdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vdata_);
  }
  _impl_.vdata_ = vdata;
  if (vdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ModelData.vData)
}
inline ::VertexData* ModelData::release_vdata() {
  
  ::VertexData* temp = _impl_.vdata_;
  _impl_.vdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::VertexData* ModelData::unsafe_arena_release_vdata() {
  // @@protoc_insertion_point(field_release:ModelData.vData)
  
  ::VertexData* temp = _impl_.vdata_;
  _impl_.vdata_ = nullptr;
  return temp;
}
inline ::VertexData* ModelData::_internal_mutable_vdata() {
  
  if (_impl_.vdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::VertexData>(GetArenaForAllocation());
    _impl_.vdata_ = p;
  }
  return _impl_.vdata_;
}
inline ::VertexData* ModelData::mutable_vdata() {
  ::VertexData* _msg = _internal_mutable_vdata();
  // @@protoc_insertion_point(field_mutable:ModelData.vData)
  return _msg;
}
inline void ModelData::set_allocated_vdata(::VertexData* vdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vdata_;
  }
  if (vdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vdata);
    if (message_arena != submessage_arena) {
      vdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vdata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vdata_ = vdata;
  // @@protoc_insertion_point(field_set_allocated:ModelData.vData)
}

// float sceneProgress = 4;
inline void ModelData::clear_sceneprogress() {
  _impl_.sceneprogress_ = 0;
}
inline float ModelData::_internal_sceneprogress() const {
  return _impl_.sceneprogress_;
}
inline float ModelData::sceneprogress() const {
  // @@protoc_insertion_point(field_get:ModelData.sceneProgress)
  return _internal_sceneprogress();
}
inline void ModelData::_internal_set_sceneprogress(float value) {
  
  _impl_.sceneprogress_ = value;
}
inline void ModelData::set_sceneprogress(float value) {
  _internal_set_sceneprogress(value);
  // @@protoc_insertion_point(field_set:ModelData.sceneProgress)
}

// -------------------------------------------------------------------

// PixelData

// uint32 r = 1;
inline void PixelData::clear_r() {
  _impl_.r_ = 0u;
}
inline uint32_t PixelData::_internal_r() const {
  return _impl_.r_;
}
inline uint32_t PixelData::r() const {
  // @@protoc_insertion_point(field_get:PixelData.r)
  return _internal_r();
}
inline void PixelData::_internal_set_r(uint32_t value) {
  
  _impl_.r_ = value;
}
inline void PixelData::set_r(uint32_t value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:PixelData.r)
}

// uint32 g = 2;
inline void PixelData::clear_g() {
  _impl_.g_ = 0u;
}
inline uint32_t PixelData::_internal_g() const {
  return _impl_.g_;
}
inline uint32_t PixelData::g() const {
  // @@protoc_insertion_point(field_get:PixelData.g)
  return _internal_g();
}
inline void PixelData::_internal_set_g(uint32_t value) {
  
  _impl_.g_ = value;
}
inline void PixelData::set_g(uint32_t value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:PixelData.g)
}

// uint32 b = 3;
inline void PixelData::clear_b() {
  _impl_.b_ = 0u;
}
inline uint32_t PixelData::_internal_b() const {
  return _impl_.b_;
}
inline uint32_t PixelData::b() const {
  // @@protoc_insertion_point(field_get:PixelData.b)
  return _internal_b();
}
inline void PixelData::_internal_set_b(uint32_t value) {
  
  _impl_.b_ = value;
}
inline void PixelData::set_b(uint32_t value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:PixelData.b)
}

// uint32 a = 4;
inline void PixelData::clear_a() {
  _impl_.a_ = 0u;
}
inline uint32_t PixelData::_internal_a() const {
  return _impl_.a_;
}
inline uint32_t PixelData::a() const {
  // @@protoc_insertion_point(field_get:PixelData.a)
  return _internal_a();
}
inline void PixelData::_internal_set_a(uint32_t value) {
  
  _impl_.a_ = value;
}
inline void PixelData::set_a(uint32_t value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:PixelData.a)
}

// -------------------------------------------------------------------

// TextureData

// string textureName = 1;
inline void TextureData::clear_texturename() {
  _impl_.texturename_.ClearToEmpty();
}
inline const std::string& TextureData::texturename() const {
  // @@protoc_insertion_point(field_get:TextureData.textureName)
  return _internal_texturename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextureData::set_texturename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.texturename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TextureData.textureName)
}
inline std::string* TextureData::mutable_texturename() {
  std::string* _s = _internal_mutable_texturename();
  // @@protoc_insertion_point(field_mutable:TextureData.textureName)
  return _s;
}
inline const std::string& TextureData::_internal_texturename() const {
  return _impl_.texturename_.Get();
}
inline void TextureData::_internal_set_texturename(const std::string& value) {
  
  _impl_.texturename_.Set(value, GetArenaForAllocation());
}
inline std::string* TextureData::_internal_mutable_texturename() {
  
  return _impl_.texturename_.Mutable(GetArenaForAllocation());
}
inline std::string* TextureData::release_texturename() {
  // @@protoc_insertion_point(field_release:TextureData.textureName)
  return _impl_.texturename_.Release();
}
inline void TextureData::set_allocated_texturename(std::string* texturename) {
  if (texturename != nullptr) {
    
  } else {
    
  }
  _impl_.texturename_.SetAllocated(texturename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.texturename_.IsDefault()) {
    _impl_.texturename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TextureData.textureName)
}

// int32 width = 2;
inline void TextureData::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t TextureData::_internal_width() const {
  return _impl_.width_;
}
inline int32_t TextureData::width() const {
  // @@protoc_insertion_point(field_get:TextureData.width)
  return _internal_width();
}
inline void TextureData::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void TextureData::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:TextureData.width)
}

// int32 height = 3;
inline void TextureData::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t TextureData::_internal_height() const {
  return _impl_.height_;
}
inline int32_t TextureData::height() const {
  // @@protoc_insertion_point(field_get:TextureData.height)
  return _internal_height();
}
inline void TextureData::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void TextureData::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:TextureData.height)
}

// bool hasAlpha = 4;
inline void TextureData::clear_hasalpha() {
  _impl_.hasalpha_ = false;
}
inline bool TextureData::_internal_hasalpha() const {
  return _impl_.hasalpha_;
}
inline bool TextureData::hasalpha() const {
  // @@protoc_insertion_point(field_get:TextureData.hasAlpha)
  return _internal_hasalpha();
}
inline void TextureData::_internal_set_hasalpha(bool value) {
  
  _impl_.hasalpha_ = value;
}
inline void TextureData::set_hasalpha(bool value) {
  _internal_set_hasalpha(value);
  // @@protoc_insertion_point(field_set:TextureData.hasAlpha)
}

// int32 pixelIndex = 5;
inline void TextureData::clear_pixelindex() {
  _impl_.pixelindex_ = 0;
}
inline int32_t TextureData::_internal_pixelindex() const {
  return _impl_.pixelindex_;
}
inline int32_t TextureData::pixelindex() const {
  // @@protoc_insertion_point(field_get:TextureData.pixelIndex)
  return _internal_pixelindex();
}
inline void TextureData::_internal_set_pixelindex(int32_t value) {
  
  _impl_.pixelindex_ = value;
}
inline void TextureData::set_pixelindex(int32_t value) {
  _internal_set_pixelindex(value);
  // @@protoc_insertion_point(field_set:TextureData.pixelIndex)
}

// repeated .PixelData pixelDataBatch = 6;
inline int TextureData::_internal_pixeldatabatch_size() const {
  return _impl_.pixeldatabatch_.size();
}
inline int TextureData::pixeldatabatch_size() const {
  return _internal_pixeldatabatch_size();
}
inline void TextureData::clear_pixeldatabatch() {
  _impl_.pixeldatabatch_.Clear();
}
inline ::PixelData* TextureData::mutable_pixeldatabatch(int index) {
  // @@protoc_insertion_point(field_mutable:TextureData.pixelDataBatch)
  return _impl_.pixeldatabatch_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PixelData >*
TextureData::mutable_pixeldatabatch() {
  // @@protoc_insertion_point(field_mutable_list:TextureData.pixelDataBatch)
  return &_impl_.pixeldatabatch_;
}
inline const ::PixelData& TextureData::_internal_pixeldatabatch(int index) const {
  return _impl_.pixeldatabatch_.Get(index);
}
inline const ::PixelData& TextureData::pixeldatabatch(int index) const {
  // @@protoc_insertion_point(field_get:TextureData.pixelDataBatch)
  return _internal_pixeldatabatch(index);
}
inline ::PixelData* TextureData::_internal_add_pixeldatabatch() {
  return _impl_.pixeldatabatch_.Add();
}
inline ::PixelData* TextureData::add_pixeldatabatch() {
  ::PixelData* _add = _internal_add_pixeldatabatch();
  // @@protoc_insertion_point(field_add:TextureData.pixelDataBatch)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PixelData >&
TextureData::pixeldatabatch() const {
  // @@protoc_insertion_point(field_list:TextureData.pixelDataBatch)
  return _impl_.pixeldatabatch_;
}

// float sceneProgress = 7;
inline void TextureData::clear_sceneprogress() {
  _impl_.sceneprogress_ = 0;
}
inline float TextureData::_internal_sceneprogress() const {
  return _impl_.sceneprogress_;
}
inline float TextureData::sceneprogress() const {
  // @@protoc_insertion_point(field_get:TextureData.sceneProgress)
  return _internal_sceneprogress();
}
inline void TextureData::_internal_set_sceneprogress(float value) {
  
  _impl_.sceneprogress_ = value;
}
inline void TextureData::set_sceneprogress(float value) {
  _internal_set_sceneprogress(value);
  // @@protoc_insertion_point(field_set:TextureData.sceneProgress)
}

// -------------------------------------------------------------------

// ObjectData

// string modelName = 1;
inline void ObjectData::clear_modelname() {
  _impl_.modelname_.ClearToEmpty();
}
inline const std::string& ObjectData::modelname() const {
  // @@protoc_insertion_point(field_get:ObjectData.modelName)
  return _internal_modelname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectData::set_modelname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.modelname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ObjectData.modelName)
}
inline std::string* ObjectData::mutable_modelname() {
  std::string* _s = _internal_mutable_modelname();
  // @@protoc_insertion_point(field_mutable:ObjectData.modelName)
  return _s;
}
inline const std::string& ObjectData::_internal_modelname() const {
  return _impl_.modelname_.Get();
}
inline void ObjectData::_internal_set_modelname(const std::string& value) {
  
  _impl_.modelname_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectData::_internal_mutable_modelname() {
  
  return _impl_.modelname_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectData::release_modelname() {
  // @@protoc_insertion_point(field_release:ObjectData.modelName)
  return _impl_.modelname_.Release();
}
inline void ObjectData::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  _impl_.modelname_.SetAllocated(modelname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.modelname_.IsDefault()) {
    _impl_.modelname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ObjectData.modelName)
}

// string textureName = 2;
inline void ObjectData::clear_texturename() {
  _impl_.texturename_.ClearToEmpty();
}
inline const std::string& ObjectData::texturename() const {
  // @@protoc_insertion_point(field_get:ObjectData.textureName)
  return _internal_texturename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ObjectData::set_texturename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.texturename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ObjectData.textureName)
}
inline std::string* ObjectData::mutable_texturename() {
  std::string* _s = _internal_mutable_texturename();
  // @@protoc_insertion_point(field_mutable:ObjectData.textureName)
  return _s;
}
inline const std::string& ObjectData::_internal_texturename() const {
  return _impl_.texturename_.Get();
}
inline void ObjectData::_internal_set_texturename(const std::string& value) {
  
  _impl_.texturename_.Set(value, GetArenaForAllocation());
}
inline std::string* ObjectData::_internal_mutable_texturename() {
  
  return _impl_.texturename_.Mutable(GetArenaForAllocation());
}
inline std::string* ObjectData::release_texturename() {
  // @@protoc_insertion_point(field_release:ObjectData.textureName)
  return _impl_.texturename_.Release();
}
inline void ObjectData::set_allocated_texturename(std::string* texturename) {
  if (texturename != nullptr) {
    
  } else {
    
  }
  _impl_.texturename_.SetAllocated(texturename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.texturename_.IsDefault()) {
    _impl_.texturename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ObjectData.textureName)
}

// .Vector3 position = 3;
inline bool ObjectData::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool ObjectData::has_position() const {
  return _internal_has_position();
}
inline void ObjectData::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::Vector3& ObjectData::_internal_position() const {
  const ::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector3&>(
      ::_Vector3_default_instance_);
}
inline const ::Vector3& ObjectData::position() const {
  // @@protoc_insertion_point(field_get:ObjectData.position)
  return _internal_position();
}
inline void ObjectData::unsafe_arena_set_allocated_position(
    ::Vector3* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ObjectData.position)
}
inline ::Vector3* ObjectData::release_position() {
  
  ::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vector3* ObjectData::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:ObjectData.position)
  
  ::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::Vector3* ObjectData::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::Vector3* ObjectData::mutable_position() {
  ::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:ObjectData.position)
  return _msg;
}
inline void ObjectData::set_allocated_position(::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:ObjectData.position)
}

// .Vector3 rotation = 4;
inline bool ObjectData::_internal_has_rotation() const {
  return this != internal_default_instance() && _impl_.rotation_ != nullptr;
}
inline bool ObjectData::has_rotation() const {
  return _internal_has_rotation();
}
inline void ObjectData::clear_rotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.rotation_ != nullptr) {
    delete _impl_.rotation_;
  }
  _impl_.rotation_ = nullptr;
}
inline const ::Vector3& ObjectData::_internal_rotation() const {
  const ::Vector3* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector3&>(
      ::_Vector3_default_instance_);
}
inline const ::Vector3& ObjectData::rotation() const {
  // @@protoc_insertion_point(field_get:ObjectData.rotation)
  return _internal_rotation();
}
inline void ObjectData::unsafe_arena_set_allocated_rotation(
    ::Vector3* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ObjectData.rotation)
}
inline ::Vector3* ObjectData::release_rotation() {
  
  ::Vector3* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vector3* ObjectData::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:ObjectData.rotation)
  
  ::Vector3* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::Vector3* ObjectData::_internal_mutable_rotation() {
  
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::Vector3* ObjectData::mutable_rotation() {
  ::Vector3* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:ObjectData.rotation)
  return _msg;
}
inline void ObjectData::set_allocated_rotation(::Vector3* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:ObjectData.rotation)
}

// .Vector3 scale = 5;
inline bool ObjectData::_internal_has_scale() const {
  return this != internal_default_instance() && _impl_.scale_ != nullptr;
}
inline bool ObjectData::has_scale() const {
  return _internal_has_scale();
}
inline void ObjectData::clear_scale() {
  if (GetArenaForAllocation() == nullptr && _impl_.scale_ != nullptr) {
    delete _impl_.scale_;
  }
  _impl_.scale_ = nullptr;
}
inline const ::Vector3& ObjectData::_internal_scale() const {
  const ::Vector3* p = _impl_.scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vector3&>(
      ::_Vector3_default_instance_);
}
inline const ::Vector3& ObjectData::scale() const {
  // @@protoc_insertion_point(field_get:ObjectData.scale)
  return _internal_scale();
}
inline void ObjectData::unsafe_arena_set_allocated_scale(
    ::Vector3* scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scale_);
  }
  _impl_.scale_ = scale;
  if (scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ObjectData.scale)
}
inline ::Vector3* ObjectData::release_scale() {
  
  ::Vector3* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vector3* ObjectData::unsafe_arena_release_scale() {
  // @@protoc_insertion_point(field_release:ObjectData.scale)
  
  ::Vector3* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
  return temp;
}
inline ::Vector3* ObjectData::_internal_mutable_scale() {
  
  if (_impl_.scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vector3>(GetArenaForAllocation());
    _impl_.scale_ = p;
  }
  return _impl_.scale_;
}
inline ::Vector3* ObjectData::mutable_scale() {
  ::Vector3* _msg = _internal_mutable_scale();
  // @@protoc_insertion_point(field_mutable:ObjectData.scale)
  return _msg;
}
inline void ObjectData::set_allocated_scale(::Vector3* scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.scale_;
  }
  if (scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scale);
    if (message_arena != submessage_arena) {
      scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scale, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.scale_ = scale;
  // @@protoc_insertion_point(field_set_allocated:ObjectData.scale)
}

// float sceneProgress = 6;
inline void ObjectData::clear_sceneprogress() {
  _impl_.sceneprogress_ = 0;
}
inline float ObjectData::_internal_sceneprogress() const {
  return _impl_.sceneprogress_;
}
inline float ObjectData::sceneprogress() const {
  // @@protoc_insertion_point(field_get:ObjectData.sceneProgress)
  return _internal_sceneprogress();
}
inline void ObjectData::_internal_set_sceneprogress(float value) {
  
  _impl_.sceneprogress_ = value;
}
inline void ObjectData::set_sceneprogress(float value) {
  _internal_set_sceneprogress(value);
  // @@protoc_insertion_point(field_set:ObjectData.sceneProgress)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fSceneLoader_2eproto
